<script>

// ========= BEGIN SCRIPTS ===============================


// ******************************************************** 
// ********** NPC FUNCTIONS ***********************
// ******************************************************** 

// ===== CHALLENGE RATING =====

function updateTotalNPCCR(id, npcTokens = null) {
    
    let totalCR = 0;
    if (npcTokens) {
        npcTokens.forEach(token => {
            // Check if it's an NPC (non-hostile)
            if (token.actor.type === 'npc' && token.document.disposition >= 0) {
                const crValue = parseFloat(token.actor.system.details.cr);
                if (!isNaN(crValue)) {
                    totalCR += crValue;
                } else {
                    console.error('CR value not found or invalid', token);
                }
            }
        });
    } else {
        const npcElements = document.querySelectorAll(`#workspace-section-npcs-content-${id} .player-card[data-type="npc"]`);
        npcElements.forEach(element => {
            const crValue = parseFloat(element.getAttribute('data-cr'));
            if (!isNaN(crValue)) {
                totalCR += crValue;
            } else {
                console.error('CR value not found or invalid', element);
            }
        });
    }
    // Format the total CR
    let formattedTotalNPCCRValue = totalCR;
    if (totalCR > 0 && totalCR < 0.125) {
        formattedTotalNPCCRValue = 0.125; // Round up to 1/8
    }

    // Get the party CR value
    const partyCRElement = document.querySelector(`#npcPartyCRValue-${id}`);
    const partyCRValue = parseFloat(partyCRElement.innerText) || 0;

    // Calculate Hero CR by adding party CR and NPC CR
    let heroCRValue = partyCRValue + formattedTotalNPCCRValue;

    // Write the NPC CR value to the NPC CR badge
    document.getElementById(`npcNPCCRValue-${id}`).innerText = formattedTotalNPCCRValue.toFixed(2);
    // Write the Hero CR value to the NPC Hero CR badge
    document.getElementById(`npcHeroCRValue-${id}`).innerText = heroCRValue.toFixed(2);
    // Write the Hero CR value to the Configuration Hero CR badge
    document.getElementById(`badgeHeroCRValue-${id}`).innerText = heroCRValue.toFixed(2);
}

// ===== DROP ZONE HANDLERS =====

// Add NPC Drop Zone Event Handlers
function addNPCDropZoneHandlers(id) {
    const dropZone = document.getElementById(`npcs-drop-zone-${id}`);
    if (!dropZone) return;

    dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', async (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.remove('dragover');

        // Get the dropped token data
        const data = JSON.parse(event.dataTransfer.getData('text/plain'));
        if (!data) return;

        // Get the token document
        const token = await fromUuid(data.uuid);
        if (!token) return;

        // Check if it's an NPC token
        if (token.actor?.type !== 'npc' || token.document.disposition < 0) {
            ui.notifications.warn("Only non-hostile NPCs can be added to the NPC worksheet.");
            return;
        }

        // Add the token to the NPC container
        const container = document.querySelector(`#workspace-section-npcs-content-${id} .npc-container`);
        if (container) {
            // Clear the message if it exists
            const message = container.querySelector('.message-box');
            if (message) message.style.display = 'none';

            // Add the token
            const tokenData = {
                actor: token.actor,
                document: token.document
            };
            const tokens = [tokenData];
            await addTokensToContainer(id, 'npc', tokens);
            updateTotalNPCCR(id);
            updateAllCounts(id);
        }
    });
}




// ******************************************************** 
// ********** MONSTER FUNCTIONS ***********************
// ******************************************************** 

// ===== CHALLENGE RATING =====

// UPDATE TOTAL MONSTER CR

function updateTotalMonsterCR(id, monsterTokens = null) {
    // Get the monsters container first
    const monstersContainer = document.querySelector(`#workspace-section-monsters-content-${id}`);
    if (!monstersContainer) {
        return;
    }

    let totalCR = 0;
    if (monsterTokens) {
        monsterTokens.forEach(monster => {
            if (monster.actor.system.details.type === "NPC") {
                return;
            }
            const crValue = parseFloat(monster.actor.system.details.cr);
            if (!isNaN(crValue)) {
                totalCR += crValue;
            } else {
                console.error('CR value not found or invalid', monster);
            }
        });
    } else {
        const monsterElements = monstersContainer.querySelectorAll('.player-card');
        monsterElements.forEach(element => {
            if (element.getAttribute('data-type') === "NPC") {
                return;
            }
            const crValue = parseFloat(element.getAttribute('data-cr'));
            if (!isNaN(crValue)) {
                totalCR += crValue;
            } else {
                console.error('CR value not found or invalid', element);
            }
        });
    }

    const crValueElement = document.getElementById(`monsterCRValue-${id}`);
    if (crValueElement) {
        crValueElement.innerText = totalCR.toFixed(2);
    }
}


// ===== GAP CR VALUE ===== 

function updateGapCRValue(id) {
    const targetCRValue = parseFloat(document.getElementById(`targetCRValue-${id}`).innerText);
    const monsterCRValue = parseFloat(document.getElementById(`monsterCRValue-${id}`).innerText);
    const gapCRValue = targetCRValue - monsterCRValue;

    const gapWorksheetElement = document.getElementById(`gapCRValue-${id}`);
    const gapBadgeElement = document.getElementById(`gapBadgeCRValue-${id}`);
    // remove the minus and set the value
    gapWorksheetElement.innerText = Math.abs(gapCRValue).toFixed(2);
    gapBadgeElement.innerText = Math.abs(gapCRValue).toFixed(2);

    const gapWorksheetContainer = gapWorksheetElement.parentElement;
    const gapBadgeContainer = gapBadgeElement.parentElement;
    gapWorksheetContainer.classList.remove('gap-lessthan', 'gap-greaterthan', 'gap-equalto');
    gapBadgeContainer.classList.remove('gap-lessthan', 'gap-greaterthan', 'gap-equalto');

    const percentageDifference = Math.abs(gapCRValue) / targetCRValue;

    if (percentageDifference <= 0.10) {
        gapWorksheetContainer.classList.add('gap-equalto');
        gapBadgeContainer.classList.add('gap-equalto');
    } else if (gapCRValue < 0) {
        gapWorksheetContainer.classList.add('gap-lessthan');
        gapBadgeContainer.classList.add('gap-lessthan');
    } else {
        gapWorksheetContainer.classList.add('gap-greaterthan');
        gapBadgeContainer.classList.add('gap-greaterthan');
    }
}


// ******************************************************** 
// ********** CHARACTER FUNCTIONS *************************
// ******************************************************** 

function updateTotalPlayerCounts(id, characterTokens = null) {
    let totalClassCounts = {};
    let partyAdjustment = 0;
    // Class TRrackers
    let partyCardTier0Adjustment = 0;
    let partyCardTier1Adjustment = 0;
    let partyCardTier2Adjustment = 0;
    let partyCardTier3Adjustment = 0;
    let partyButtonTier0Adjustment = 0;
    let partyButtonTier1Adjustment = 0;
    let partyButtonTier2Adjustment = 0;
    let partyButtonTier3Adjustment = 0;
    let totalButtonTier0Adjustment = 0;
    let totalButtonTier1Adjustment = 0;
    let totalButtonTier2Adjustment = 0;
    let totalButtonTier3Adjustment = 0;
    // Level Trackers
    let partyLevel = 0;
    let totalCardLevel1to4 = 0;
    let totalCardLevel5to10 = 0;
    let totalCardLevel11to16 = 0;
    let totalCardLevel17to20 = 0;
    let totalButtonLevel1to4 = 0;
    let totalButtonLevel5to10 = 0;
    let totalButtonLevel11to16 = 0;
    let totalButtonLevel17to20 = 0;
    let totalLevel1to4 = 0;
    let totalLevel5to10 = 0;
    let totalLevel11to16 = 0;
    let totalLevel17to20 = 0;

    if (characterTokens) {
        characterTokens.forEach(character => {
            // get the level and class and update counts.
        });
    } else {

        // *** Upadtes CLASS and LEVEL based on LEVEL BUTTONS ***

        const characterTypes = Array.from(document.querySelectorAll(`#workspace-section-encounter-${id} .class-button`))
            .map(el => {
                const countElement = el.querySelector('.count');
                return countElement && parseInt(countElement.innerText) > 0 ? { class: el.dataset.class, count: parseInt(countElement.innerText) } : null;
            })
            .filter(Boolean);

        // Calculate Party Adjustments for the buttons
        let partyAdjustment = 0;
        characterTypes.forEach(({ class: type, count }) => {
            switch (type) {
                case 'wizard':
                    partyButtonTier3Adjustment += 0.3 * count;
                    break;
                case 'cleric':
                case 'bard':
                case 'druid':
                    partyButtonTier2Adjustment += 0.2 * count;
                    break;
                case 'paladin':
                case 'sorcerer':
                case 'warlock':
                    partyButtonTier1Adjustment += 0.1 * count;
                    break;
                case 'monk':
                case 'ranger':
                    partyButtonTier1Adjustment -= 0.1 * count;
                    break;
                // artificer, fighter, barbarian, rogue, or anything else: 0 (No adjustment)
                default:
                    break;
            }
        });

        // button levels
        const levelElements = document.querySelectorAll(`#workspace-section-encounter-${id} .level-button`);
        levelElements.forEach(element => {
            const level = parseInt(element.getAttribute('data-level'));
            const countElement = element.querySelector('.count');
            
            if (countElement) {
                const count = parseInt(countElement.innerText);
                if (level >= 1 && level <= 4) {
                    totalButtonLevel1to4 += level * count;
                } else if (level >= 5 && level <= 10) {
                    totalButtonLevel5to10 += level * count;
                } else if (level >= 11 && level <= 16) {
                    totalButtonLevel11to16 += level * count;
                } else if (level >= 17 && level <= 20) {
                    totalButtonLevel17to20 += level * count;
                }
            } else {
                console.error('Count element not found', element);
            }
        });

        // *** Upadtes CLASS and LEVEL based on the CHARACTER CARDS ***
        const cardElements = document.querySelectorAll(`#workspace-section-tokens-content-${id} .player-card`);
        cardElements.forEach(element => {
            if (element.getAttribute('data-type') === "NPC") {
                return;
            }

            // Class Counts
            const characterClassValue = element.getAttribute('data-class');
            if (characterClassValue) {
                // depending on the class, adjust the party adjustment
                switch (characterClassValue) {
                    case 'wizard':
                        partyCardTier3Adjustment += 0.3;
                        break;
                    case 'cleric':
                    case 'bard':
                    case 'druid':
                        partyCardTier2Adjustment += 0.2;
                        break;
                    case 'paladin':
                    case 'sorcerer':
                    case 'warlock':
                        partyCardTier1Adjustment += 0.1;
                        break;
                    case 'monk':
                    case 'ranger':
                        partyCardTier0Adjustment -= 0.1;
                        break;
                    // artificer, fighter, barbarian, rogue, or anything else: 0 (No adjustment)
                    default:
                        break;
                }

            } else {
                console.error('CLASS value not found or invalid', element);
            }

            // Level Counts
            const characterLevelValue = parseFloat(element.getAttribute('data-level'));
            if (!isNaN(characterLevelValue)) {
                // adjust the level value based on the level of the character
                if (characterLevelValue >= 1 && characterLevelValue <= 4) {
                    totalCardLevel1to4 += characterLevelValue;
                } else if (characterLevelValue >= 5 && characterLevelValue <= 10) {
                    totalCardLevel5to10 += characterLevelValue;
                } else if (characterLevelValue >= 11 && characterLevelValue <= 16) {
                    totalCardLevel11to16 += characterLevelValue;
                } else if (characterLevelValue >= 17 && characterLevelValue <= 20) {
                    totalCardLevel17to20 += characterLevelValue;
                }
            } else {
                console.error('LEVEL value not found or invalid', element);
            }
        });
    }
    // do not double count buttons and cards sincd the card count will also be in the button count.
    if (totalButtonLevel1to4 === 0) {
        totalLevel1to4 = totalCardLevel1to4;
    } else {
        totalLevel1to4 = totalCardLevel1to4 + (totalButtonLevel1to4 - totalCardLevel1to4);
    }
    if (totalButtonLevel5to10 === 0) {
        totalLevel5to10 = totalCardLevel5to10;
    } else {
        totalLevel5to10 = totalCardLevel5to10 + (totalButtonLevel5to10 - totalCardLevel5to10);
    }
    if (totalButtonLevel11to16 === 0) {
        totalLevel11to16 = totalCardLevel11to16;
    } else {
        totalLevel11to16 = totalCardLevel11to16 + (totalButtonLevel11to16 - totalCardLevel11to16);
    }
    if (totalButtonLevel17to20 === 0) {
        totalLevel17to20 = totalCardLevel17to20;
    } else {
        totalLevel17to20 = totalCardLevel17to20 + (totalButtonLevel17to20 - totalCardLevel17to20);
    }
    // Do the math for the total party level.
    partyLevel = (totalLevel1to4 / 4) + (totalLevel5to10 / 2) + (totalLevel11to16 * 0.75) + totalLevel17to20;
    partyLevel = partyLevel.toFixed(2);
    const partyLevelElement = document.querySelector(`#worksheetPartyLevel-${id}`);
    // Check if the element exists and set its inner text to partyLevel
    if (partyLevelElement) {
        partyLevelElement.innerText = partyLevel;
    } else {
        console.error(`Element with id worksheetPartyLevel-${id} not found.`);
    }

    // Get the tier adjustments
    totalButtonTier0Adjustment = partyCardTier0Adjustment + (partyButtonTier0Adjustment - partyCardTier0Adjustment);
    totalButtonTier1Adjustment = partyCardTier1Adjustment + (partyButtonTier1Adjustment - partyCardTier1Adjustment);
    totalButtonTier2Adjustment = partyCardTier2Adjustment + (partyButtonTier2Adjustment - partyCardTier2Adjustment);
    totalButtonTier3Adjustment = partyCardTier3Adjustment + (partyButtonTier3Adjustment - partyCardTier3Adjustment);
    // Get the total adjustment
    partyAdjustment = totalButtonTier0Adjustment + totalButtonTier1Adjustment + totalButtonTier2Adjustment + totalButtonTier3Adjustment;
    partyAdjustment = (partyAdjustment >= 0 ? '+' : '') + partyAdjustment.toFixed(2);
    // SET THE PARTY ADJUSTMENT WORKSHEET BADGE
    const partyAdjustmentElement = document.querySelector(`#worksheetPartyAdjustment-${id}`);
    if (partyAdjustmentElement) {
        partyAdjustmentElement.innerText = partyAdjustment;
    } else {
        console.error(`Element with id worksheetPartyAdjustment-${id} not found.`);
    }

    // SET THE PARTY CR WORKSHEET BADGE
    let partyCRValue = parseFloat(partyLevel) + parseFloat(partyAdjustment);
    partyCRValue = partyCRValue.toFixed(2);
    const partyCRElement = document.querySelector(`#worksheetPartyCR-${id}`);
    if (partyCRElement) {
        partyCRElement.innerText = partyCRValue;
    } else {
        console.error(`Element with id worksheetPartyCR-${id} not found.`);
    }
    const npcCRElement = document.querySelector(`#npcPartyCRValue-${id}`);
    if (npcCRElement) {
        npcCRElement.innerText = partyCRValue;
    } else {
        console.error(`Element with id npcPartyCRValue-${id} not found.`);
    }
}


// ===== CHARACTERLEVELS =====

// INCREMENT LEVEL COUNT

function incrementLevelCount(element, levelCount, id) {
    const countSpan = element.querySelector('.count');
    let count = parseInt(countSpan.innerText, 10);
    const level = parseInt(element.getAttribute('data-level'), 10);
    
    // Get the number of player cards at this level BEFORE incrementing
    const cardElements = document.querySelectorAll(`#workspace-section-tokens-content-${id} .player-card[data-level="${level}"]`);
    const minCount = cardElements.length;
    
    // Increment the count
    count += 1;
    countSpan.innerText = count;

    // Apply "auto" status if count equals minCount, otherwise "active"
    if (count === minCount) {
        element.classList.remove('active');
        element.classList.add('auto');
    } else if (count > minCount) {
        element.classList.remove('auto');
        element.classList.add('active');
        
        // Add placeholder card for manual addition
        const container = document.querySelector(`#workspace-section-tokens-content-${id} .tokens-container`);
        const placeholderCard = createPlaceholderCard(id, 'level', level);
        container.appendChild(placeholderCard);
    }

    if (count === 0) {
        element.classList.remove('active');
        element.classList.remove('auto');
    }
    updateTotalPlayerCounts(id);
    updateEncounterDetails(id);
    updateCharacterTypeDisplay(element);
}

// DECREMENT LEVEL COUNT

function decrementLevelCount(event, button, levelCount, id) {
    event.preventDefault();
    event.stopPropagation();
    const element = button.parentElement;
    const countSpan = element.querySelector('.count');
    let count = parseInt(countSpan.innerText, 10);
    const level = parseInt(element.getAttribute('data-level'), 10);

    // Get the number of player cards at this level
    const cardElements = document.querySelectorAll(`#workspace-section-tokens-content-${id} .player-card[data-level="${level}"]`);
    const minCount = cardElements.length;

    if (count > minCount) {
        count -= 1;
        countSpan.innerText = count;
    } else {
        ui.notifications.warn("The remaining class counts are set by character cards. Remove character cards from the worksheet to reduce the level count.");
    }

    // Apply "auto" status if count equals minCount, otherwise "active"
    if (count === minCount) {
        element.classList.remove('active');
        element.classList.add('auto');
    } else if (count > minCount) {
        element.classList.remove('auto');
        element.classList.add('active');
    } else {
        element.classList.remove('active');
        element.classList.remove('auto');
    }

    // Check if count is 0
    if (count === 0) {
        element.classList.remove('active');
        element.classList.remove('auto');
    }

    updateTotalPlayerCounts(id);
    updateCharacterTypeDisplay(element);
    updateEncounterDetails(id);
}

// ===== CHARACTER TYPES =====

// CREATE PLACEHOLDER CARD
function createPlaceholderCard(id, type, value) {
    const card = document.createElement('div');
    card.className = 'player-card placeholder-card';
    card.setAttribute('data-type', 'player');
    
    if (type === 'level') {
        card.setAttribute('data-level', value);
        card.setAttribute('data-class', 'placeholder');
        card.innerHTML = `
            <div class="player-card-details">
                <div class="character-name">Level ${value}</div>
                <div class="character-details character-rollup">Manual Addition</div>
            </div>
            <button type="button" class="clear-button" onclick="removeCard(event, this, '${id}')">x</button>
        `;
    } else { // class
        card.setAttribute('data-level', '0');
        card.setAttribute('data-class', value);
        card.innerHTML = `
            <div class="player-card-details">
                <div class="character-name">${value}</div>
                <div class="character-details character-rollup">Manual Addition</div>
            </div>
            <button type="button" class="clear-button" onclick="removeCard(event, this, '${id}')">x</button>
        `;
    }
    
    return card;
}

// INCREMENT CHARACTER TYPE

function incrementCharacterType(element, characterType, id) {
    const countSpan = element.querySelector('.count');
    let count = parseInt(countSpan.innerText);
    const dataClass = element.getAttribute('data-class');
    
    // Get the number of player cards with this class BEFORE incrementing
    const cardElements = document.querySelectorAll(`#workspace-section-tokens-content-${id} .player-card[data-class="${dataClass}"]`);
    const minCount = cardElements.length;
    
    // Increment the count
    count += 1;
    countSpan.innerText = count;

    // Apply "auto" status if count equals minCount, otherwise "active"
    if (count === minCount) {
        element.classList.remove('active');
        element.classList.add('auto');
    } else if (count > minCount) {
        element.classList.remove('auto');
        element.classList.add('active');
        
        // Add placeholder card for manual addition
        const container = document.querySelector(`#workspace-section-tokens-content-${id} .tokens-container`);
        const placeholderCard = createPlaceholderCard(id, 'class', dataClass);
        container.appendChild(placeholderCard);
    }

    updateCharacterTypeDisplay(element);
    updateTotalPlayerCounts(id);
    updateEncounterDetails(id);
}

// DECREMENT CHARACTER TYPE

function decrementCharacterType(event, button, characterType, id) {
    event.preventDefault();
    event.stopPropagation();
    const element = button.parentElement;
    const countSpan = element.querySelector('.count');
    let count = parseInt(countSpan.innerText, 10);
    const dataClass = element.getAttribute('data-class'); // Ensure this is a string

    // Get the number of player cards with the matching data-class
    const cardElements = document.querySelectorAll(`#workspace-section-tokens-content-${id} .player-card[data-class="${dataClass}"]`);
    const minCount = cardElements.length;

    if (count > minCount) {
        count -= 1;
        countSpan.innerText = count;
    } else {
        ui.notifications.warn("The remaining class counts are set by character cards. Remove character cards from the worksheet to reduce the class count.");
    }

    // Apply "auto" status if count equals minCount, otherwise "active"
    if (count === minCount) {
        element.classList.remove('active');
        element.classList.add('auto');
    } else if (count > minCount) {
        element.classList.remove('auto');
        element.classList.add('active');
    } else {
        element.classList.remove('active');
        element.classList.remove('auto');
    }

    // Check if count is 0
    if (count === 0) {
        element.classList.remove('active');
        element.classList.remove('auto');
    }

    updateCharacterTypeDisplay(element);
    updateTotalPlayerCounts(id);
    updateEncounterDetails(id);
}

// UPDATE CHARACTER TYPE DISPLAY

function updateCharacterTypeDisplay(element) {
    const countSpan = element.querySelector('.count');
    const clearButton = element.querySelector('.clear-button');
    if (parseInt(countSpan.innerText) > 0) {
        countSpan.style.display = 'inline';
        clearButton.style.display = 'inline';
    } else {
        countSpan.style.display = 'none';
        clearButton.style.display = 'none';
    }
}

// ******************************************************** 
// ********** GLOBAL FUNCTIONS ****************************
// ******************************************************** 

// ===== CARDS AND CARD COUNTS =====

// REMOVE CARD
window.removeCard = function(event, button, id) {
    event.preventDefault();
    event.stopPropagation();
    const card = button.closest('.player-card');
    if (!card) return;

    const cardType = card.dataset.type || 'monster';  // Default to 'monster' for backward compatibility

    // First, Remove the card
    card.remove();

    // Now tha the card is removed, If this is a player card, trigger the decrement functions before removal
    if (cardType === 'player') {
        const cardLevel = parseInt(card.getAttribute('data-level'));
        const cardClass = card.getAttribute('data-class');
        
        // Find and trigger decrement on the level button
        const levelButton = document.querySelector(`#workspace-section-encounter-${id} .level-button[data-level="${cardLevel}"] .clear-button`);
        if (levelButton) {
            decrementLevelCount({ preventDefault: () => {}, stopPropagation: () => {} }, levelButton, cardLevel, id);
        }
        
        // Find and trigger decrement on the class button
        const classButton = document.querySelector(`#workspace-section-encounter-${id} .class-button[data-class="${cardClass}"] .clear-button`);
        if (classButton) {
            decrementCharacterType({ preventDefault: () => {}, stopPropagation: () => {} }, classButton, cardClass, id);
        }
    }

    // If this is an encounter card, update the encounters data
    if (cardType === 'encounter') {
        const form = document.querySelector(`#blacksmith-query-workspace-narrative`);
        if (form) {
            const encountersInput = form.querySelector('#input-encounters-data');
            if (encountersInput) {
                try {
                    let encountersData = JSON.parse(encountersInput.value || '[]');
                    // Remove the encounter with matching UUID
                    encountersData = encountersData.filter(e => e.uuid !== card.dataset.pageUuid);
                    encountersInput.value = JSON.stringify(encountersData);
                } catch (e) {
                    console.error('BLACKSMITH | Regent: Error updating encounters data:', e);
                }
            }
        }
    } else {
        updateAllCounts(id, cardType);
    }
};

// UPDATE ALL COUNTS
window.updateAllCounts = function(id, cardType = null) {
   
    // Only update monster CR if we're not dealing with encounters
    if (cardType !== 'encounter') {
        // Monster Updates
        updateTotalMonsterCR(id);
        
        // Player Updates
        updateTotalPlayerCounts(id);
        
        // NPC Updates
        updateTotalNPCCR(id);
        
        // Total Updates
        updateEncounterDetails(id);
        
        // Update the slider
        updateSlider(id);
    }
};

// ===== ENCOUNTER SLIDER =====

// UPDATE SLIDER VALUE

function updateSlider(id, passedValue = null) {
    
    // Needs to set the lower end
    // needs to set the upper end
    // if passed, it needs to set the value (which sill set the target cr)
    // if it is NOT passed, we shoudl use the slider value to set the target cr
    
    const crSlider = document.getElementById(`optionCR-${id}`);
    let sliderPassedValue = passedValue;
    let sliderCurrentValue = crSlider.value;
    let heroCRValue = 0;
    let monsterCRValue = 0;
    let targetCRValue = 0;
    let lowerLimit = 0;
    let upperLimit = 0;
    let upperLimitDefault = 200;

    // Get the Hero CR value from the badge
    const heroCRElement = document.getElementById(`badgeHeroCRValue-${id}`);
    if (heroCRElement) {
        heroCRValue = parseFloat(heroCRElement.innerText.trim());
    } else {
        console.error(`Element with id badgeHeroCRValue-${id} not found.`);
        heroCRValue = 0;
    }




    // MONSTER CR 
    const monsterCRValueElement = document.querySelector(`#monsterCRValue-${id}`);
    if (monsterCRValueElement) {
        monsterCRValue = parseFloat(monsterCRValueElement.innerText.trim());
    } else {
        console.error(`Element with id monsterCRValue-${id} not found.`);
        monsterCRValue = 0;
    }

    // TARGET CR -- Change this so that if one is passed, use it, otherwaise grab it.
    // Find the element with the specified id
    const targetCRValueElement = document.querySelector(`#targetCRValue-${id}`);
    const partyBenchmarkValue = parseFloat(heroCRValue) || 0;
    const monsterCRValueNumber = parseFloat(monsterCRValue) || 0;

    // Determine the greater value between partyBenchmarkValue and monsterCRValueNumber
    const maxBenchmarkOrMonsterCR = Math.max(partyBenchmarkValue, monsterCRValueNumber);

    // Set the max of the slider
    if (maxBenchmarkOrMonsterCR > 0) {
        upperLimit = (maxBenchmarkOrMonsterCR * 2.5) + 10; // Adding a buffer of 10
    } else {
        upperLimit = upperLimitDefault;
    }
    crSlider.max = upperLimit;

    // Set the slider's value to the provided value or the targetCRValue or minimum value
    if (sliderPassedValue !== null) {
        crSlider.value = sliderPassedValue;
        targetCRValue = sliderPassedValue;
    } else {
        //crSlider.value = targetCRValue !== null ? targetCRValue : crSlider.min;
        // we just used the slider value as dragged
        targetCRValue = crSlider.value;
    }
   
    // Update both targetCRValue elements
    const targetCRValueNumber = parseFloat(targetCRValue) || 0;
    document.querySelectorAll(`#targetCRValue-${id}`).forEach(element => {
        element.innerText = targetCRValueNumber.toFixed(2);
    });
    // update the gap value
    updateGapCRValue(id); 

    

    // Define boolean flags for difficulty levels
    const blnDifficultyNone = targetCRValue <= 0;
    const blnDifficultyTrivial = targetCRValue > 0 && targetCRValue < heroCRValue / 4;
    const blnDifficultyEasy = targetCRValue >= heroCRValue / 4 && targetCRValue < heroCRValue / 2;
    const blnDifficultyModerate = targetCRValue >= heroCRValue / 2 && targetCRValue < heroCRValue * 1;
    const blnDifficultyHard = targetCRValue >= heroCRValue && targetCRValue < heroCRValue * 1.5;
    const blnDifficultyDeadly = targetCRValue >= heroCRValue * 1.5 && targetCRValue < heroCRValue * 1.75;
    const blnDifficultyDeadlySlow = targetCRValue >= heroCRValue * 1.75 && targetCRValue < heroCRValue * 2;
    const blnDifficultyDeadlyMedium = targetCRValue >= heroCRValue * 2 && targetCRValue < heroCRValue * 2.25;
    const blnDifficultyImpossible = targetCRValue >= heroCRValue * 2.25;




    // Set the encounter rating badge
    let encounterRating;
    let ratingClass;
    let iconClass;
    if (blnDifficultyNone) {
        encounterRating = "Set Difficulty";
        ratingClass = "encounter-rating-none";
        iconClass = "fa-solid fa-users-gear";
    } else if (blnDifficultyTrivial) {
        encounterRating = "Trivial";
        ratingClass = "encounter-rating-trivial";
        iconClass = "fa-solid fa-rabbit";
    } else if (blnDifficultyEasy) {
        encounterRating = "Easy";
        ratingClass = "encounter-rating-easy";
        iconClass = "fa-solid fa-pig";
    } else if (blnDifficultyModerate) {
        encounterRating = "Moderate";
        ratingClass = "encounter-rating-medium";
        iconClass = "fa-solid fa-ram";
    } else if (blnDifficultyHard) {
        encounterRating = "Hard";
        ratingClass = "encounter-rating-hard";
        iconClass = "fa-solid fa-dragon";
    } else if (blnDifficultyDeadly) {
        encounterRating = "Deadly";
        ratingClass = "encounter-rating-deadly";
        iconClass = "fa-solid fa-dragon";
    } else if (blnDifficultyDeadlySlow) {
        encounterRating = "Deadly";
        ratingClass = "encounter-rating-deadly-slow";
        iconClass = "fa-solid fa-dragon";
    } else if (blnDifficultyDeadlyMedium) {
        encounterRating = "Deadly";
        ratingClass = "encounter-rating-deadly-medium";
        iconClass = "fa-solid fa-dragon";
    } else if (blnDifficultyImpossible) {
        encounterRating = "Impossible";
        ratingClass = "encounter-rating-impossible";
        iconClass = "fa-solid fa-skull";
    } else {
        encounterRating = "Set Difficulty";
        ratingClass = "encounter-rating-none";
        iconClass = "fa-solid fa-users-gear";
    }

    // Set the encounter rating badge
    const ratingElement = document.getElementById(`encounter-rating-${id}`);
    ratingElement.className = `encounter-rating-badge ${ratingClass}`;
    ratingElement.innerHTML = `<i class="${iconClass}"></i> ${encounterRating}`;
}


// ===== PARTY CR =====

// UPDATE ENCOUNTER DETAILS AND ALL COUNTS

function updateEncounterDetails(id) {
    
    // this largely just passes values badges and calls the slider update

    let partyLevel = 0;
    let partyAdjustment = 0;
    let partyCRValue;
    let targetCRValue = 0;
    let monsterCRValue = 0;
    //let gapCRValue = 0;


    // PARTY LEVEL
    const partyLevelElement = document.querySelector(`#worksheetPartyLevel-${id}`);
    // Check if the element exists
    if (partyLevelElement) {
        // Parse the inner text of the element to a floating-point number
        partyLevel = parseFloat(partyLevelElement.innerText);
    } else {
        console.error(`Element with id worksheetPartyLevel-${id} not found.`);
        partyLevel = 0;
    }


    // PARTY ADJUSTMENT
     // Find the element with the specified id
    const partyAdjustmentElement = document.querySelector(`#worksheetPartyAdjustment-${id}`);
    // Check if the element exists
    if (partyAdjustmentElement) {
        // Get the inner text of the element
        partyAdjustment = partyAdjustmentElement.innerText.trim();

    } else {
        console.error(`Element with id worksheetPartyAdjustment-${id} not found.`);
        partyAdjustment = 0;
    }


    // Party CR
   // Find the element with the specified id
    const partyCRElement = document.getElementById(`worksheetPartyCR-${id}`);

    if (partyCRElement) {
        partyCRValue = parseFloat(partyCRElement.innerText.trim());
    } else {
        console.error(`Element with id worksheetPartyCR-${id} not found.`);
        partyCRValue = 0;
    }

    // MONSTER CR
    // Find the element with the specified id
    const monsterCRValueElement = document.querySelector(`#monsterCRValue-${id}`);

    // Check if the element exists and set targetCRValue
    if (monsterCRValueElement) {
        monsterCRValue = parseFloat(monsterCRValueElement.innerText.trim());
    } else {
        console.error(`Element with id monsterCRValue-${id} not found.`);
        monsterCR = 0;
    }


    // TARGET CR
    // Find the element with the specified id
    const targetCRValueElement = document.querySelector(`#targetCRValue-${id}`);

    // Check if the element exists and set targetCRValue
    if (targetCRValueElement) {
        targetCRValue = parseFloat(targetCRValueElement.innerText.trim());
    } else {
        console.error(`Element with id targetCRValue-${id} not found.`);
        targetCRValue = 0;
    }

    // SET THE BADGE VALUES

    // Get NPC CR Value
    const npcCRElement = document.querySelector(`#npcNPCCRValue-${id}`);
    let npcCRValue = 0;
    if (npcCRElement) {
        npcCRValue = parseFloat(npcCRElement.innerText) || 0;
    }

    // PARTY CR BADGE (now includes NPC CR for total Hero CR)
    const badgeHeroCRElement = document.querySelector(`#badgeHeroCRValue-${id}`);
    if (badgeHeroCRElement) {
        const totalHeroCR = partyCRValue + npcCRValue;
        badgeHeroCRElement.innerText = totalHeroCR.toFixed(2);
    } else {
        console.error(`Element with id #badgeHeroCRValue-${id} not found.`);
    }

    // MONSTER CR BADGE
    const badgeMonsterCRElement = document.querySelector(`#badgeMonsterCRValue-${id}`);
    if (badgeMonsterCRElement) {
        badgeMonsterCRElement.innerText = monsterCRValue.toFixed(2);
    } else {
        console.error(`Element with id badgeMonsterCRValue-${id} not found.`);
    }

}


// ========= END SCRIPTS ===============================
</script>



