name: ROADMAP to ISSUES (Auto or Manual)

on:
  # push:
  #   paths:
  #     - 'ROADMAP.md'
  #   branches:
  #     - master
  workflow_dispatch:  # Allow manual trigger only

permissions:
  contents: read
  issues: write
  repository-projects: write

jobs:
  sync-to-issues:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: Create Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const labels = [
              { name: 'blacksmith', color: '1d76db', description: 'Coffee Pub Blacksmith Module' },
              { name: 'bug', color: 'd73a4a', description: 'Something isn\'t working' },
              { name: 'enhancement', color: 'a2eeef', description: 'New feature or request' },
              { name: 'documentation', color: '0075ca', description: 'Documentation improvements' },
              { name: 'timer', color: 'fbca04', description: 'Timer related features' },
              { name: 'ui', color: 'bfdadc', description: 'User interface improvements' },
              { name: 'performance', color: '0e8a16', description: 'Performance improvements' },
              { name: 'api', color: '1d76db', description: 'API related changes' },
              { name: 'combat', color: 'd93f0b', description: 'Combat related features' },
              { name: 'data', color: 'c5def5', description: 'Data management features' },
              { name: 'planning', color: 'c2e0c6', description: 'Planning phase features' },
              { name: 'integration', color: 'fef2c0', description: 'Integration features' },
              { name: 'security', color: 'd93f0b', description: 'Security improvements' },
              { name: 'feature', color: '0052cc', description: 'New features' }
            ];
            
            for (const label of labels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  // Label already exists, update it
                  try {
                    await github.rest.issues.updateLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: label.name,
                      color: label.color,
                      description: label.description
                    });
                    console.log(`Updated label: ${label.name}`);
                  } catch (updateError) {
                    console.log(`Error updating label ${label.name}:`, updateError);
                  }
                } else {
                  console.log(`Error creating label ${label.name}:`, error);
                }
              }
            }

      - name: Update Issues from ROADMAP.md
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Add delay function to prevent rate limiting
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            
            // Add retry function for rate limited operations
            async function retryWithBackoff(operation, maxRetries = 3) {
              let lastError;
              for (let i = 0; i < maxRetries; i++) {
                try {
                  return await operation();
                } catch (error) {
                  lastError = error;
                  if (error.status === 403 && error.response?.data?.message?.includes('rate limit')) {
                    const waitTime = Math.pow(2, i) * 10000; // Exponential backoff: 10s, 20s, 40s
                    console.log(`Rate limited. Waiting ${waitTime/1000} seconds before retry ${i + 1}/${maxRetries}`);
                    await delay(waitTime);
                    continue;
                  }
                  throw error;
                }
              }
              throw lastError;
            }
            
            try {
              // Get project data first
              const projectQuery = `
                query($owner: String!) {
                  user(login: $owner) {
                    projectV2(number: 3) {
                      id
                      fields(first: 20) {
                        nodes {
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const projectResult = await github.graphql(projectQuery, {
                owner: context.repo.owner
              });
              
              // Add delay after project query
              await delay(1000);
              
              const project = projectResult.user.projectV2;
              const statusField = project.fields.nodes.find(field => field.name === 'Status');
              const priorityField = project.fields.nodes.find(field => field.name === 'Priority');
              
              // Read and parse ROADMAP.md
              const content = fs.readFileSync('ROADMAP.md', 'utf8');
              const sections = {};
              let currentSection = null;
              
              // Parse the markdown content
              for (const line of content.split('\n')) {
                if (line.startsWith('## ')) {
                  currentSection = line.substring(3).trim();
                  sections[currentSection] = [];
                } else if (line.startsWith('- ') && currentSection) {
                  // Parse the line for title, priority, and labels
                  let title = line.substring(2);
                  let priority = 'P0';
                  let labels = ['blacksmith'];
                  
                  // Extract priority if present
                  const priorityMatch = title.match(/\[Priority: (P\d+)\]/);
                  if (priorityMatch) {
                    priority = priorityMatch[1];
                    title = title.replace(/\[Priority: P\d+\]/, '').trim();
                  }
                  
                  // Extract labels if present
                  const labelMatch = title.match(/\[Label: ([^\]]+)\]/);
                  if (labelMatch) {
                    const customLabels = labelMatch[1].split(',').map(l => l.trim());
                    labels = [...customLabels]; // Revert to original simple label handling
                    title = title.replace(/\[Label: [^\]]+\]/, '').trim();
                  }
                  
                  sections[currentSection].push({
                    title,
                    priority,
                    labels,
                    state: currentSection === 'CLOSED' ? 'closed' : 'open',
                    status: currentSection
                  });
                }
              }
              
              // Get existing issues
              const { data: existingIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all'
              });
              
              // Add delay after getting issues
              await delay(1000);
              
              // Process each section
              for (const [sectionName, items] of Object.entries(sections)) {
                for (const item of items) {
                  let issueNumber;
                  
                  // Check if issue already exists
                  const existingIssue = existingIssues.find(issue => 
                    issue.title === item.title
                  );
                  
                  if (existingIssue) {
                    // Update existing issue
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: existingIssue.number,
                      state: item.state,
                      labels: item.labels
                    });
                    
                    issueNumber = existingIssue.number;
                    console.log(`Updated issue: ${item.title}`);
                  } else {
                    // Create new issue
                    const { data: newIssue } = await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: item.title,
                      body: `Priority: ${item.priority}\nCreated from ROADMAP.md`,
                      labels: item.labels,
                      state: item.state
                    });
                    
                    issueNumber = newIssue.number;
                    console.log(`Created new issue: ${item.title}`);
                  }
                  
                  await delay(2000);
                  
                  /* Comment out project automation for now
                  // Add to project and set status
                  const addToProjectMutation = `
                    mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: {
                        projectId: $projectId
                        contentId: $contentId
                      }) {
                        item {
                          id
                        }
                      }
                    }
                  `;
                  
                  // Get issue node ID
                  const issueQuery = `
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        issue(number: $number) {
                          id
                        }
                      }
                    }
                  `;
                  
                  const issueResult = await github.graphql(issueQuery, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    number: issueNumber
                  });
                  
                  const projectResult = await github.graphql(addToProjectMutation, {
                    projectId: project.id,
                    contentId: issueResult.repository.issue.id
                  });
                  
                  const itemId = projectResult.addProjectV2ItemById.item.id;
                  
                  // Set status
                  const statusOption = statusField.options.find(opt => opt.name === item.status);
                  if (statusOption) {
                    await github.graphql(`
                      mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                        updateProjectV2ItemFieldValue(
                          input: {
                            projectId: $projectId
                            itemId: $itemId
                            fieldId: $fieldId
                            value: { 
                              singleSelectOptionId: $optionId
                            }
                          }
                        ) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `, {
                      projectId: project.id,
                      itemId: itemId,
                      fieldId: statusField.id,
                      optionId: statusOption.id
                    });
                  }
                  
                  // Set priority
                  const priorityOption = priorityField.options.find(opt => opt.name === item.priority);
                  if (priorityOption) {
                    await github.graphql(`
                      mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                        updateProjectV2ItemFieldValue(
                          input: {
                            projectId: $projectId
                            itemId: $itemId
                            fieldId: $fieldId
                            value: { 
                              singleSelectOptionId: $optionId
                            }
                          }
                        ) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `, {
                      projectId: project.id,
                      itemId: itemId,
                      fieldId: priorityField.id,
                      optionId: priorityOption.id
                    });
                  }
                  */
                }
              }
              
              console.log('Successfully synced ROADMAP.md to issues');
              
            } catch (error) {
              console.error('Error syncing ROADMAP.md to issues:', error);
              console.error('Full error:', JSON.stringify(error, null, 2));
              process.exit(1);
            } 